# Внутри

> ![IMPORTANT] Здесь содержатся `KaTeX`
макросы. Это лучше смотреть с документ в 
web-версии GitHub или в Visual Studio Code.

На данный момент рассматривается пока что два способа решения
совместных систем линейных уравнений: метод Крамера
и метод линейных преобразований (или метод Гаусса).
Для метода Крамера Определитель матрицы рекурсивно считается разложением
на алгебраические дополнения.

Сложность вычисления определителя матрицы, согласно
"BigO" нотации составляет `O(n!)`, что не сильно
ощущается при вычислении определителей матриц
до десятого порядка. Для матриц порядка выше десятого,
это может быть плохим решением.

## Использование методов для разрешения СЛАУ
Для вывода решения и самой системы линейных уравнений, 
используются наследующие `IProvider` объекты.

```csharp
class KramerMethodProvider : IProvider { }
```

Суть `IProvider`-подобных сущностей решении
и в описании шагов решения для заданной системы линейных
уравнений

Все функции, которые разрешают задачу ~пусть и процедурно~
скрываются от пользователя `IProvider` сущности, и предоставляют
результат в модели данных

```
ComputingModel {get; private set;}
    MainSystemFormula           <string>
    MainSystemSolutionFormula   <string>
```

Если матрица генерируется, (требуется из ничего создавать большой объект),
каждый конструктор провайдера метода требует `MethodProviderParameters`
Структура параметров для метод-провайдера содержит пять основных параметров,
учитывающихся обязательно, и один специфический флаг -- требование отказаться от метода линейных преобразований
(на данный момент это флаг метода Крамера), поэтому фабричным методом, этот флаг учитывается
и проверяются остальные флаги (ниже).

```
MethodProviderParameters:
    Ordinal             <i32>
    Rank                <i32>
    MakeInConsistent    <bool>
    MakeUndefined       <bool>
    MakeHomogenous      <bool>
```

## Представление и хранение данных
Основной тип данных в котором хранится вся матрица коэффициентов
это тип обыкновенной дроби `Frac32`. Интуитивно понятно, что 
структура представляет собой числитель и знаменатель дроби
в виде целочисленных 32-разрядных данных.

```csharp
struct Frac32 
{
    int Enumerator {get; private set;}
    int Denominator {get; private set;}
    
    /* другие части реализации */
}
```

К сожалению, `Frac32` не расширяется благодаря
`IComparable<T>`, `IEquatable<T>` и других интерфейсов,
испольщующихся в описаниях стандартных типов данных .NET...,
но операторы сравнения, сложения, умножения и другие реализованы.

## `MatrixGenerator` - как создаются системы уравнений?
Сущность `MatrixGenerator` предоставляет несколько методов
для создания системы линейных алгебраических уравнений,
три из которых можно выбрать самому в приложении, так как они
применяются для создания совместной определенной СЛАУ.

```csharp
public MatrixGenerator(
    int ordinal,
    int rank,
    LinearCastingGeneratorType type
    int minimum,
    int maximum,
    bool isConsistent,
    bool isHomogenous,
    bool isUndefined
)
```

По сути, на момент обновления документации, вся структура
`MethodProviderParameters` переносится сюда. И не факт, что это навсегда.
Дальнейшие действия по рефакторингу приложения предстоят, и все будет
переноситься одной структурой, в целях "не писать монстров в виде типичной
GDI функции"

Функции создания матрицы все до единой имеют тип возвращаемого
значения `(Frac32[,]; Frac32[])`. Это кортеж, который содержит
основную матрицу системы (вертикальный массив `Frac32[,]`) и
столбец свободных коэффициентов `Frac32[]`.

Все функции используют псевдо-случайные значения, заданные
диапозоном от минимума до максимума.

### Метод Псевдо-случайных коэффициентов
Замысел простой. Все массивы данных заполняются дробями
с числителем, который изменяется от `minimum` до `maximum`.

Вызов:
```CSharp
(Frac32[,] coefficients, Frac[] constants) = _instance.GenerateRandomFrac32Matrix();
```

### Метод Треугольных матриц
Идея метода треугольных матриц в том, что изначально задается 
единичная матрица определенного порядка `ordinal`. Далее
просто линейно комбинируется, превращаясь в верхнюю
треугольную матрицу, и далее так же заполняется.

Вызов:
```CSharp
(Frac32[,] coefficients, Frac[] constants) = _instance.GenerateTriangleFrac32Matrix();
```

### Метод Ортогонализации
Метод ортогонализации Грама — Шмидта — это алгоритм в 
линейной алгебре, который позволяет преобразовать набор 
векторов в ортогональный и ортонормированный базис.

Суть алгоритма в том, что он последовательно строит 
попарно ортогональные векторы $\{b_1, b_2, ..., b_n\}$ 
подпространства $S$ евклидова пространства $E$ 
($S$ может и совпадать со всём пространством $E$). 
Затем, нормируя векторы $\{b_1, b_2, ..., b_n\}$, 
получают ортонормированный базис.

```CSharp
(Frac32[,] coefficients, Frac[] constants) = _instance.GenerateOrthogonalFrac32Matrix();
```

> Все, что описывается далее, не гарантирует
100% создание требуемой системы линейных уравнений

### Создание несовместной системы линейных уравнений
Существует классический случай несовместности системы.
Рассмотрим его.

$$
W_{ext} = 
\begin{bmatrix}
    1 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 \\
    0 & 0 & 0 & 1
\end{bmatrix}
$$

Данная матрица $W$ пусть и представляет собой эшелон столбцов (ступенчатую матрицу),
содержит строку 3, где явно выполняется неравенство $0 \neq 1$

Алгоритм создания несовместной матрицы как раз рассматривает подобную ситцацию,
но генерирует линейно зависимые столбцы основной матрицы системы, предположим

$$
W_{common} = 
\begin{bmatrix}
    -7 & -3 & 1 \\
    1 & 5 & 7 & \\
    \alpha & 5\alpha & 7\alpha
\end{bmatrix} W_{free} =
\begin{bmatrix}
    \beta  \\
    \gamma  \\
    \delta  \\
\end{bmatrix}
$$

Где $\alpha$ случайное число, обеспечивающее эффект "замыленного глаза"
при попытке заметить закономерности.
Остальные элементы просто представляют собой случайные числа
и заполняются следующим шагом после заполнения
основной матрицы коэффициентов $W_{common}$

Вызов:
```CSharp
(Frac32[,] coefficients, Frac[] constants) = _instance.GenerateInConsistentFrac32Matrix();
```


### Метод неопределенных совместных систем линейных уравнений

Метод для неопределенных совместных СЛАУ,
так же рассматривает теорему Кранекера-Капелли,
рассматривает случай линейной зависимости строк,

Сначала генерируются линейно независимые строки (определяется рангом матрицы)
уже для расширенной матрицы
$$
J_{ext} = 
\begin{bmatrix}
    -7 & -3 & 1 & 3\\
    \dots & \dots & \dots
\end{bmatrix}
$$

После генерации линейно-независимых строк, когда $i > r(J_{ext})$,
идет генерация линейно-зависимых строк.
создается строка коэффициентов $[\alpha, \alpha, \alpha, \alpha]$
и умножается на случайно созданный вектор чисел например $[4, 2, 5, 6]$

$$
J_{ext} = 
\begin{bmatrix}
    -7 & -3 & 1 & 3\\
    4\alpha & 2\alpha & 5\alpha & 6\alpha \\
    \dots & \dots & \dots
\end{bmatrix}
$$

Следующей итерацией, создается столбец коэффициентов $\beta$,
идея повторяется

$$
J_{ext} = 
\begin{bmatrix}
    -7 & -3 & 1 & 3\\
    4\alpha & 2\alpha & 5\alpha & 6\alpha \\
    4\beta & 2\beta & 5\beta & 6\beta \\
\end{bmatrix}
$$

Соответственно, обеспечивается линейная зависимость, и
другие параметры от пользователя, но никто не исколючает
случайные совпадения.

Вызов:
```CSharp
(Frac32[,] coefficients, Frac[] constants) = _instance.GenerateUndefinedFrac32Matrix();
```
